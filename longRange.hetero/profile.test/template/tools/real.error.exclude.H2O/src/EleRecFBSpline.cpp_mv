#include "ElectrostaticInteraction.h"
#include "Polynominal.h"
#include "VectorOperation.h"
#include <numeric>
#include <math.h>
#include <time.h>
#include "Integral1D.h"
#include "ToolBox.h"


// static double global_x;
// static double global_u;
// static unsigned global_m;


double intPow (const double & x, const unsigned & alpha_);

double ElectrostaticInteraction_rec_FBSpline::fenmu (const value_type & u, const unsigned & _2m)
{
  
  if (u == 0) return 0;
  int A = 3;
  double fenmu = 0;
  for (int i = -A+1; i < A; ++i){
    fenmu += 1./intPow (u+2*M_PI*i, _2m);
  }
  fenmu += ( 1./ (2.*M_PI * (_2m-1) * intPow(u + 2*M_PI*(A-0.5), _2m-1)) -
	     1./ (2.*M_PI * (_2m-1) * intPow(u - 2*M_PI*(A-0.5), _2m-1)) );
  return fenmu;
}
double ElectrostaticInteraction_rec_FBSpline::fenzi (const value_type & u, const unsigned & _2m)
{
  if (u == 0) return 0;
  int A = 3;
  double fenmu = 0;
  for (int i = -A+1; i < A; ++i){
    if (i == 0) continue;
    fenmu += 1./intPow (u+2*M_PI*i, _2m);
  }
  fenmu += ( 1./ (2.*M_PI * (_2m-1) * intPow(u + 2*M_PI*(A-0.5), _2m-1)) -
	     1./ (2.*M_PI * (_2m-1) * intPow(u - 2*M_PI*(A-0.5), _2m-1)) );
  return fenmu;
}
double ElectrostaticInteraction_rec_FBSpline::avg_e2 (const value_type & u, const unsigned & _2m)
{
  if (u == 0) return 0;
  double fenmua = fenmu (u, _2m);
  double fenzia = fenzi (u, _2m);
  return (fenzi(u, 2*_2m) + fenzia * fenzia) / fenmua / fenmua;
}

double ElectrostaticInteraction_rec_FBSpline::avg_e (const value_type & u, const unsigned & _2m)
{
  if (u == 0) return 0;
  int A = 3;
  double fenmu = 0;
  for (int i = -A+1; i < A; ++i){
    fenmu += 1./intPow (u+2*M_PI*i, _2m);
  }
  fenmu += ( 1./ (2.*M_PI * (_2m-1) * intPow(u + 2*M_PI*(A-0.5), _2m-1)) -
	     1./ (2.*M_PI * (_2m-1) * intPow(u - 2*M_PI*(A-0.5), _2m-1)) );
  double fenzi = fenmu - 1./intPow (u, _2m);
  return - fenzi / fenmu;
}

double ElectrostaticInteraction_rec_FBSpline::avg_epe (const value_type & u, const unsigned & _2m)
{
  if (u == 0) return 0;
  int A = 3;
  double result = 0;
  double fenmua = fenmu (u, _2m);
  for (int i = -A+1; i < A; ++i){
    if (i == 0) continue;
    result += 1./intPow (u+2*M_PI*i, 2*_2m) * 2 * M_PI * i;
  }
  return result / fenmua / fenmua;
}

double ElectrostaticInteraction_rec_FBSpline::avg_epep (const value_type & u, const unsigned & _2m)
{
  if (u == 0) return 0;
  int A = 3;
  double result = 0;
  double fenmua = fenmu (u, _2m);
  for (int i = -A+1; i < A; ++i){
    if (i == 0) continue;
    result += 1./intPow (u+2*M_PI*i, 2*_2m) * 4 * M_PI * M_PI * i * i;
  }
  return result / fenmua / fenmua;
}



std::vector<double > ElectrostaticInteraction_rec_FBSpline::error (const value_type & u, const value_type & x, const unsigned & _2m)
{
//   global_m = _2m/2;
//   global_u = u;
//   global_x = x;
  int A = 3;
  
  if ( u == 0){
    return std::vector<double > (2,0);
  }
  double fenmu = 0;
  for (int i = -A+1; i < A; ++i){
    fenmu += 1./intPow (u+2*M_PI*i, _2m);
  }
  fenmu += ( 1./ (2.*M_PI * (_2m-1) * intPow(u + 2*M_PI*(A-0.5), _2m-1)) -
	     1./ (2.*M_PI * (_2m-1) * intPow(u - 2*M_PI*(A-0.5), _2m-1)) );
  
  std::vector<double > fenzi (2, 0);
  for (int i = -A+1; i < A; ++i){
    fenzi[0] += (cos(2*M_PI*i*x) - 1) / intPow (u+2*M_PI*i, _2m);
    fenzi[1] += (sin(2*M_PI*i*x)    ) / intPow (u+2*M_PI*i, _2m);
  }
  double c = fenzi[0] / fenmu;
  double d = fenzi[1] / fenmu;
  
  std::vector<double > tmp(2);
  tmp[0] = c;
  tmp[1] = d;
  return tmp;
}

std::vector<double > ElectrostaticInteraction_rec_FBSpline::derror (const value_type & u, const value_type & x, const unsigned & _2m)
{
//   global_m = _2m/2;
//   global_u = u;
//   global_x = x;
  int A = 2;
  
  if ( u == 0){
    return std::vector<double > (2,0);
  }
  double fenmu = 0;
  for (int i = -A+1; i < A; ++i){
    fenmu += 1./intPow (u+2*M_PI*i, _2m);
  }
  fenmu += ( 1./ (2.*M_PI * (_2m-1) * intPow(u + 2*M_PI*(A-0.5), _2m-1)) -
	     1./ (2.*M_PI * (_2m-1) * intPow(u - 2*M_PI*(A-0.5), _2m-1)) );
  
  std::vector<double > fenzi (2, 0);
  for (int i = -A+1; i < A; ++i){
    fenzi[0] +=-2*M_PI*i * sin(2*M_PI*i*x) / intPow (u+2*M_PI*i, _2m);
    fenzi[1] += 2*M_PI*i * cos(2*M_PI*i*x) / intPow (u+2*M_PI*i, _2m);
  }
//   Integral1D <MFP, value_type > inte;
//   std::cout << "est fenzi " << fenzi[0] << '\t' << fenzi[1] << std::endl;
//   fenzi[0] += inte.cal_int (Integral1DInfo::Gauss4, value0, -1./(A-0.5), 1./(A-0.5), 1e-10, 5*(unsigned(x)+1));
//   fenzi[1] += inte.cal_int (Integral1DInfo::Gauss4, value1, -1./(A-0.5), 1./(A-0.5), 1e-10, 5*(unsigned(x)+1));
  
//   std::cout << "est fenzi " << fenzi[0] << '\t' << fenzi[1] << std::endl;

  double c = fenzi[0] / fenmu;
  double d = fenzi[1] / fenmu;
  
  std::vector<double > tmp(2);
  tmp[0] = c;
  tmp[1] = d;
  return tmp;
}



value_type ElectrostaticInteraction_rec_FBSpline::errorEstimate () 
{
  //   std::cout << "error0: " << error (0.5*M_PI, 0.1, 4) << std::endl;
  //   std::cout << "error1: " << error1(0.5*M_PI, 0.1, 4) << std::endl;
  //   exit (1);

  unsigned n = Mn->getN();
  
  //   unsigned m = n / 2;

  std::vector<double > KK (3);
  KK[0] = K[0];
  KK[1] = K[1];
  KK[2] = K[2];  
  //   double h0 = 1./KK[0];
  //   double h1 = 1./KK[1];
  //   double h2 = 1./KK[2];
  
  std::vector<double > qs;
  for (std::vector<StandardParticle * >::iterator pp = partPool.begin();
       pp != partPool.end(); ++pp){
    qs.push_back ((*pp)->charge());
  }
  double Q = 0;
  for (std::vector<double >::iterator i = qs.begin();
       i != qs.end(); ++ i){
    Q += *i * *i;
  }

  double sum = 0;
  double sum0 = 0;
  double sum1 = 0;
  double sum2 = 0;
  std::vector<double > errorForce(3, 0);
  for (int m0 = -int(KK[0]/2)+1; m0 < KK[0]/2; ++m0){
    for (int m1 = -int(KK[1]/2)+1; m1 < KK[1]/2; ++m1){
      for (int m2 = -int(KK[2]/2)+1; m2 < KK[2]/2; ++m2){
	if (fabs(m0) + fabs(m1) + fabs(m2) == 0) continue;
	std::vector<value_type > m (3);
	m[0] = m0 * vecAStar[0][0] + m1 * vecAStar[1][0] + m2 * vecAStar[2][0];
	m[1] = m0 * vecAStar[0][1] + m1 * vecAStar[1][1] + m2 * vecAStar[2][1];
	m[2] = m0 * vecAStar[0][2] + m1 * vecAStar[1][2] + m2 * vecAStar[2][2];
	double mm = VectorOperation::dot (m, m);
	double ees = 0;
	double eet = 0;

// 	int count = 0;
// 	for (; count < 50; ++count){
// 	  std::vector<value_type > r(3);
// 	  std::vector<value_type > u(3);
// 	  r[0] = ToolBox::genrand_real2();
// 	  r[1] = ToolBox::genrand_real2();
// 	  r[2] = ToolBox::genrand_real2();
// 	  u[0] = KK[0] * r[0];
// 	  u[1] = KK[1] * r[1];
// 	  u[2] = KK[2] * r[2];
// 	  std::vector<double > a = error(2*M_PI*m0/KK[0], u[0], n);
// 	  std::vector<double > b = error(2*M_PI*m1/KK[1], u[1], n);
// 	  std::vector<double > c = error(2*M_PI*m2/KK[2], u[2], n);
// 	  std::vector<double > sumpart0 (2, 0);
// 	  sumpart0[0] = a[0] + b[0] + c[0];
// 	  sumpart0[1] = a[1] + b[1] + c[1];
// 	  std::vector<double > eRe (3, 0);
// 	  std::vector<double > eIm (3, 0);
// 	  VectorOperation::add (eRe, -2 * M_PI * sumpart0[1], m);
// 	  VectorOperation::add (eIm,  2 * M_PI * sumpart0[0], m);
// 	  std::vector<double > ep (2, 0);
// 	  ep = derror(2*M_PI*m0/KK[0], u[0], n);
// 	  VectorOperation::add (eRe, ep[0] * KK[0], vecAStar[0]);
// 	  VectorOperation::add (eIm, ep[1] * KK[0], vecAStar[0]);
// 	  ep = derror(2*M_PI*m1/KK[1], u[1], n);
// 	  VectorOperation::add (eRe, ep[0] * KK[1], vecAStar[1]);
// 	  VectorOperation::add (eIm, ep[1] * KK[1], vecAStar[1]);
// 	  ep = derror(2*M_PI*m2/KK[2], u[2], n);
// 	  VectorOperation::add (eRe, ep[0] * KK[2], vecAStar[2]);
// 	  VectorOperation::add (eIm, ep[1] * KK[2], vecAStar[2]);
// 	  eet += (eRe[0] * eRe[0] + eIm[0] * eIm[0] + 
// 		  eRe[1] * eRe[1] + eIm[1] * eIm[1] + 
// 		  eRe[2] * eRe[2] + eIm[2] * eIm[2] );
// 	  std::vector<double > errorfunc (2, 0);
// 	  errorfunc[0] = a[0] + b[0] + c[0];
// 	  errorfunc[1] = a[1] + b[1] + c[1];
// 	  ees += errorfunc[0]*errorfunc[0] + errorfunc[1]*errorfunc[1];
// 	}
// 	ees /= count;
// 	eet /= count;

	double expp = exp (- 2*M_PI*M_PI/beta/beta*mm) / (mm*mm) * 1/(2*M_PI*V) * 1/(2*M_PI*V);
	double eemid = ( avg_e (2*M_PI*m0/KK[0], n) + 
			 avg_e (2*M_PI*m1/KK[1], n) + 
			 avg_e (2*M_PI*m2/KK[2], n) );
	eemid = eemid * eemid * (4*M_PI*M_PI*mm ) ;
	ees = (avg_e2(2*M_PI*m0/KK[0], n) + avg_e2 (2*M_PI*m1/KK[1], n) + avg_e2 (2*M_PI*m2/KK[2], n) +
	       2 * avg_e (2*M_PI*m0/KK[0], n) * avg_e (2*M_PI*m1/KK[1], n) +
	       2 * avg_e (2*M_PI*m1/KK[1], n) * avg_e (2*M_PI*m2/KK[2], n) + 
	       2 * avg_e (2*M_PI*m0/KK[0], n) * avg_e (2*M_PI*m2/KK[2], n));
	eet = 4 * M_PI * M_PI * mm * ees + 
	    4 * M_PI * (VectorOperation::dot(m, vecAStar[0]) * K[0] * avg_epe (2*M_PI*m0/KK[0], n) + 
			VectorOperation::dot(m, vecAStar[1]) * K[1] * avg_epe (2*M_PI*m1/KK[1], n) + 
			VectorOperation::dot(m, vecAStar[2]) * K[2] * avg_epe (2*M_PI*m2/KK[2], n) ) +
	    (K[0] * K[0] * VectorOperation::dot(vecAStar[0], vecAStar[0]) * avg_epep (2*M_PI*m0/KK[0], n) + 
	     K[1] * K[1] * VectorOperation::dot(vecAStar[1], vecAStar[1]) * avg_epep (2*M_PI*m1/KK[1], n) + 
	     K[2] * K[2] * VectorOperation::dot(vecAStar[2], vecAStar[2]) * avg_epep (2*M_PI*m2/KK[2], n) ) ;
	


// 	std::cout << avg_e (2*M_PI*m0/KK[0], n) << '\t'
// 		  << avg_e (2*M_PI*m1/KK[1], n) << '\t'
// 		  << m2<< '\t'<< avg_e (2*M_PI*m2/KK[2], n) << '\n';
	
	sum +=  4*expp *(ees*(4*M_PI*M_PI*mm) + eet + 2 * eemid);
	sum0 += 4*expp * ees*(4*M_PI*M_PI*mm);
	sum1 += 4*expp * 2 * eemid;
	sum2 += 4*expp * eet;
      }


// 	for (; count < 50; ++count){
// 	  std::vector<value_type > r(3);
// 	  std::vector<value_type > u(3);
// 	  r[0] = ToolBox::genrand_real2();
// 	  r[1] = ToolBox::genrand_real2();
// 	  r[2] = ToolBox::genrand_real2();
// 	  u[0] = KK[0] * r[0];
// 	  u[1] = KK[1] * r[1];
// 	  u[2] = KK[2] * r[2];
// 	  double mr = m0*r[0] + m1*r[1] + m2*r[2];
// 	  std::vector<double > a = error(2*M_PI*m0/KK[0], u[0], n);
// 	  std::vector<double > b = error(2*M_PI*m1/KK[1], u[1], n);
// 	  std::vector<double > c = error(2*M_PI*m2/KK[2], u[2], n);
// 	  std::vector<double > sumpart0 (2, 0);
// 	  sumpart0[0] = a[0] + b[0] + c[0];
// 	  sumpart0[1] = a[1] + b[1] + c[1];
// 	  std::vector<double > factor0 (2, 0);
// 	  factor0[0] =-2 * M_PI * sin(2 * M_PI * mr);
// 	  factor0[1] = 2 * M_PI * cos(2 * M_PI * mr);
// 	  std::vector<double > eRe (3, 0);
// 	  std::vector<double > eIm (3, 0);
// 	  VectorOperation::add (eRe, factor0[0]*sumpart0[0] - factor0[1]*sumpart0[1], m);
// 	  VectorOperation::add (eIm, factor0[1]*sumpart0[0] + factor0[0]*sumpart0[1], m);
// 	  std::vector<double > factor1 (2, 0);
// 	  factor1[0] = cos(2 * M_PI * mr);
// 	  factor1[1] = sin(2 * M_PI * mr);
// 	  std::vector<double > ep (2, 0);
// 	  ep = derror(2*M_PI*m0/KK[0], u[0], n);
// 	  VectorOperation::add (eRe, (factor1[0]*ep[0] - factor1[1]*ep[1]) * KK[0], vecAStar[0]);
// 	  VectorOperation::add (eIm, (factor1[1]*ep[0] + factor1[0]*ep[1]) * KK[0], vecAStar[0]);
// 	  ep = derror(2*M_PI*m1/KK[1], u[1], n);
// 	  VectorOperation::add (eRe, (factor1[0]*ep[0] - factor1[1]*ep[1]) * KK[1], vecAStar[1]);
// 	  VectorOperation::add (eIm, (factor1[1]*ep[0] + factor1[0]*ep[1]) * KK[1], vecAStar[1]);
// 	  ep = derror(2*M_PI*m2/KK[2], u[2], n);
// 	  VectorOperation::add (eRe, (factor1[0]*ep[0] - factor1[1]*ep[1]) * KK[2], vecAStar[2]);
// 	  VectorOperation::add (eIm, (factor1[1]*ep[0] + factor1[0]*ep[1]) * KK[2], vecAStar[2]);
// 	  eet += (eRe[0] * eRe[0] + eIm[0] * eIm[0] + 
// 		  eRe[1] * eRe[1] + eIm[1] * eIm[1] + 
// 		  eRe[2] * eRe[2] + eIm[2] * eIm[2] );
// 	  std::vector<double > errorfunc (2, 0);
// 	  errorfunc[0] = a[0] + b[0] + c[0];
// 	  errorfunc[1] = a[1] + b[1] + c[1];
// 	  ees += errorfunc[0]*errorfunc[0] + errorfunc[1]*errorfunc[1];
// 	}
// 	ees /= count;
// 	eet /= count;
// 	double expp = exp (- 2*M_PI*M_PI/beta/beta*mm) / (mm*mm) * 1/(2*M_PI*V) * 1/(2*M_PI*V);
// 	sum += expp * (ees*(4*M_PI*M_PI*mm) + eet);
//       }


    } 
  }
  sum *= Q*Q/double(partPool.size());
  std::cout << sum0 << '\t' << sum1 <<'\t' << sum2 << std::endl;
  return sqrt(sum);

//   return sqrt(sumsum);


}


value_type ElectrostaticInteraction_rec_FBSpline::errorEstimateDir (double rcut)
{
  
  std::vector<double > qs;
  for (std::vector<StandardParticle * >::iterator pp = partPool.begin();
       pp != partPool.end(); ++pp){
    qs.push_back ((*pp)->charge());
  }
  std::sort (qs.begin(), qs.end());
  double qmax = qs[qs.size()-1];
  double Q = 0;
  for (std::vector<double >::iterator i = qs.begin();
       i != qs.end(); ++ i){
    Q += *i * *i;
  }  

  return 2 * qmax * sqrt (Q / rcut / V) * exp (- beta*beta*rcut*rcut);
}



void ElectrostaticInteraction_rec_FBSpline::calForce_tmp (
    std::vector<StandardParticle * >::iterator beginPool,
    std::vector<StandardParticle * >::iterator endPool
{
  int M = 32;
  force.clear();
  force.resize(3, 0);
  std::cout << "tmp force calculater" << std::endl;
  
  for (int m0 = -M; m0 <= M; m0 ++){
    for (int m1 = -M; m1 <= M; m1 ++){
      for (int m2 = -M; m2 <= M; m2 ++){
	if (m0 == 0 && m1 == 0 && m2 == 0 ) continue;
	std::vector<value_type > m (3);
	m[0] = m0 * vecAStar[0][0] + m1 * vecAStar[1][0] + m2 * vecAStar[2][0];
	m[1] = m0 * vecAStar[0][1] + m1 * vecAStar[1][1] + m2 * vecAStar[2][1];
	m[2] = m0 * vecAStar[0][2] + m1 * vecAStar[1][2] + m2 * vecAStar[2][2];
	double mm = VectorOperation::dot (m, m);
	double expp = exp (-M_PI * M_PI * mm / beta / beta) / mm;
	double sum = 0;
	for (std::vector<StandardParticle * >::iterator ppart = partPool.begin();
	     ppart != partPool.end(); ppart ++){
	  std::vector<double > diff = (partPool[0])->r();
	  VectorOperation::add (diff, -1, (*ppart)->r());
	  double tmp = 2 * M_PI * VectorOperation::dot (m, diff);
	  sum += (*ppart)->charge() * sin (tmp);
	}
	sum *= (partPool[0])->charge();
	force[0] += expp * sum * 2./ V * m[0];
	force[1] += expp * sum * 2./ V * m[1];
	force[2] += expp * sum * 2./ V * m[2];
      }
    }
  }
//   std::cout << "tmp force calculater: force Of part" << std::endl;
//   std::cout << (partPool[0])->r() [0] << '\t'
// 	    << (partPool[0])->r() [1] << '\t'
// 	    << (partPool[0])->r() [2] << '\n';
  std::cout << "the force is " << std::endl;
  std::cout << force [0] << '\t'
	    << force [1] << '\t'
	    << force [2] << '\n';
  std::cout << std::endl;
  
}


value_type ElectrostaticInteraction_rec_FBSpline::calPotential_tmp (const double & time, 
								    const BoxGeometry & box)
{
  int M = 32; 
  std::cout << "cal poten exact with beta " << beta << std::endl;
  double poten = 0;
  for (int m0 = -M; m0 <= M; m0 ++){
    for (int m1 = -M; m1 <= M; m1 ++){
      for (int m2 = -M; m2 <= M; m2 ++){
	if (m0 == 0 && m1 == 0 && m2 == 0 ) continue;
	std::vector<value_type > m (3);
	m[0] = m0 * vecAStar[0][0] + m1 * vecAStar[1][0] + m2 * vecAStar[2][0];
	m[1] = m0 * vecAStar[0][1] + m1 * vecAStar[1][1] + m2 * vecAStar[2][1];
	m[2] = m0 * vecAStar[0][2] + m1 * vecAStar[1][2] + m2 * vecAStar[2][2];
	double mm = VectorOperation::dot (m, m);
	double expp = exp (-M_PI * M_PI * mm / beta / beta) / mm;
	std::vector<value_type > sm (2);
	sm[0] = 0;
	sm[1] = 0;
	for (std::vector<StandardParticle * >::iterator ppart = partPool.begin();
	     ppart != partPool.end(); ppart ++){
	  double tmp = 2 * M_PI * VectorOperation::dot (m, (*ppart)->r());
	  sm[0] += (*ppart)->charge() * cos(tmp);
	  sm[1] += (*ppart)->charge() * sin(tmp);
	}
	poten += expp * (sm[0] * sm[0] + sm[1] * sm[1]);
      }
    }
  }
  poten /= 2 * M_PI * V;
  return poten;
}




void ElectrostaticInteraction_rec_FBSpline::applyInteraction (const double & time, 
							      const BoxGeometry & box)
{
  //   calForce_tmp (time, box);

  unsigned n = Mn->getN();

//   unsigned size = K[0] * K[1] * K[2];
//   double sizei = 1./size;

  clock_t tic, toc;
  
  tic = clock();
  toc = clock();
  //   std::cout << "time rec force conv part: " << (toc - tic) / double(CLOCKS_PER_SEC) << std::endl;

  tic = clock();
  double ii0 = 1./ value_type(K[0]);
  double ii1 = 1./ value_type(K[1]);
  double ii2 = 1./ value_type(K[2]);
  bool fast = ((n < K[0]) && (n < K[1]) && (n < K[2]));
  
  for (std::vector<StandardParticle * >::iterator ppart = partPool.begin();
       ppart != partPool.end(); ppart ++){
    std::vector<value_type > u(3);
    u[0] = K[0] * VectorOperation::dot (vecAStar[0], (*ppart)->r());
    u[1] = K[1] * VectorOperation::dot (vecAStar[1], (*ppart)->r());
    u[2] = K[2] * VectorOperation::dot (vecAStar[2], (*ppart)->r());
    value_type tmp0 = 0;
    value_type tmp1 = 0;
    value_type tmp2 = 0;
    value_type dtmp0 = 0;
    value_type dtmp1 = 0;
    value_type dtmp2 = 0;
    std::vector<double > force (3, 0);
    
    if (!fast){
      int count = 0;
      for (unsigned k0 = 0; k0 < K[0]; k0 ++){
	for (unsigned k1 = 0; k1 < K[1]; k1 ++){
	  for (unsigned k2 = 0; k2 < K[2]; k2 ++, count ++){
	    value_type n0 = floor ((u[0] - k0) * ii0);
	    if (u[0] - k0 - n0 * K[0] < n){
	      Mn->value (u[0] - k0 - n0 * K[0], tmp0);
	      Mn->derivative (u[0] - k0 - n0 * K[0], dtmp0);
// 	      std::cout << tmp0 <<'\t' << dtmp0 << std::endl;
	    }
	    else{
	      continue;
	    }
	    value_type n1 = floor ((u[1] - k1) * ii1);
	    if (u[1] - k1 - n1 * K[1] < n){
	      Mn->value (u[1] - k1 - n1 * K[1], tmp1);
	      Mn->derivative (u[1] - k1 - n1 * K[1], dtmp1);
// 	      std::cout << tmp1 <<'\t' << dtmp1 << std::endl;
	    }
	    else{
	      continue;
	    }
	    value_type n2 = floor ((u[2] - k2) * ii2);
	    if (u[2] - k2 - n2 * K[2] < n){
	      Mn->value (u[2] - k2 - n2 * K[2], tmp2);
	      Mn->derivative (u[2] - k2 - n2 * K[2], dtmp2);
// 	      std::cout << tmp2 <<'\t' << dtmp2 << std::endl;
// 	      exit(1);
	    }
	    else{
	      continue;
	    }
	    VectorOperation::add (force, -QConvPsi[count] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
	    VectorOperation::add (force, -QConvPsi[count] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
	    VectorOperation::add (force, -QConvPsi[count] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
	  }
	}
      }
    }
    else{
      int A0 = -int(floor ((u[0]) * ii0)) ;
      int A1 = -int(floor ((u[1]) * ii1)) ;
      int A2 = -int(floor ((u[2]) * ii2)) ;
      value_type posi0 = u[0] + A0 * K[0];
      value_type posi1 = u[1] + A1 * K[1];
      value_type posi2 = u[2] + A2 * K[2];
      unsigned index0, index1;

      for (int k0 = int(ceil(posi0-n)); k0 < int(ceil(posi0)); ++ k0){
	Mn->value (posi0 - k0, tmp0);
	Mn->derivative (posi0 - k0, dtmp0);
	index0 = K[1] * (k0<0 ? k0+K[0] : k0);
	for (int k1 = int(ceil(posi1-n)); k1 < int(ceil(posi1)); ++ k1){
	  Mn->value (posi1 - k1, tmp1);
	  Mn->derivative (posi1 - k1, dtmp1);
	  index1 = K[2] * ((k1<0 ? k1+K[1] : k1) + index0);
	  for (int k2 = int(ceil(posi2-n)); k2 < int(ceil(posi2)); ++ k2){
	    Mn->value (posi2 - k2, tmp2);
	    Mn->derivative (posi2 - k2, dtmp2);
	    unsigned index = (k2<0 ? k2+K[2] : k2) + index1;
	    VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
	    VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
	    VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
	  }
	}
      }
    }

    (*ppart)->f()[0] += 2 * (*ppart)->charge() * force[0];
    (*ppart)->f()[1] += 2 * (*ppart)->charge() * force[1];
    (*ppart)->f()[2] += 2 * (*ppart)->charge() * force[2];
  }
}



//       if (posi0 < n){
// 	for (unsigned k0 = 0; k0 < unsigned (ceil(posi0)); k0 ++){
// 	  Mn->value (u[0] - k0 + A0 * K[0], tmp0);
// 	  Mn->derivative (u[0] - k0 + A0 * K[0], dtmp0);
// 	  ...;
// 	}
// 	for (unsigned k0 = unsigned(ceil(posi0+K[0]-n)); k0 < K[0]; k0 ++){
// 	  Mn->value (u[0] - k0 + (A0+1) * K[0], tmp0);
// 	  Mn->derivative (u[0] - k0 + (A0+1) * K[0], dtmp0);
// 	  ...;
// 	}
//       }
//       else{
// 	for (unsigned k0 = unsigned(ceil(posi0-n)); k0 < unsigned(ceil(posi0)); k0 ++){
// 	  Mn->value (u[0] - k0 + A0 * K[0], tmp0);
// 	  Mn->derivative (u[0] - k0 + A0 * K[0], dtmp0);
// 	  ...;
// 	}
//       }

//       if (posi1 < n){
// 	for (unsigned k1 = 0; k1 < unsigned (ceil(posi1)); k1 ++){
// 	  Mn->value (u[1] - k1 + A1 * K[1], tmp1);
// 	  Mn->derivative (u[1] - k1 + A1 * K[1], dtmp1);
// 	  ...;
// 	}
// 	for (unsigned k1 = unsigned(ceil(posi1+K[1]-n)); k1 < K[1]; k1 ++){
// 	  Mn->value (u[1] - k1 + (A1+1) * K[1], tmp1);
// 	  Mn->derivative (u[1] - k1 + (A1+1) * K[1], dtmp1);
// 	  ...;
// 	}
//       }
//       else{
// 	for (unsigned k1 = unsigned(ceil(posi1-n)); k1 < unsigned(ceil(posi1)); k1 ++){
// 	  Mn->value (u[1] - k1 + A1 * K[1], tmp1);
// 	  Mn->derivative (u[1] - k1 + A1 * K[1], dtmp1);
// 	  ...;
// 	}
//       }
		
//       if (posi2 < n){
// 	for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 	  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 	  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 	  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 	    VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 	    VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 	    VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 	}
// 	for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 	  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 	  Mn->derivative (u[2] - k2 + (A2+1) * K[2], dtmp2);
// 	  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 	    VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 	    VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 	    VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 	}
//       }
//       else{
// 	for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 	  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 	  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 	  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 	    VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 	    VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 	    VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 	}
//       }




value_type ElectrostaticInteraction_rec_FBSpline::calPotential (const double & time, 
							       const BoxGeometry & box)
{
  clock_t tic = clock();
  calQ();
  clock_t toc = clock();
  //   std::cout << "time rec potential Q part: " << double(toc - tic)/CLOCKS_PER_SEC << std::endl;

  tic = clock();
  fftw_execute (forwardQ);
  for (unsigned i = 0; i < K[0]*K[1]*(K[2]/2+1); i ++){
    QFProdPsiF[i][0] = QF[i][0] * psiF[i][0] - QF[i][1] * psiF[i][1];
    QFProdPsiF[i][1] = QF[i][0] * psiF[i][1] + QF[i][1] * psiF[i][0];
  }
  fftw_execute (backwardQFProdPsiF);
  int size = K[0]*K[1]*K[2];
  value_type sizei = 1./size;
  value_type value = 0;
  for (int i = 0; i < size; i ++){
    QConvPsi[i] *= sizei;
    value += Q[i] * QConvPsi[i];
  }
  toc = clock();
  //   std::cout << "time rec potential conv part: " << double(toc - tic)/CLOCKS_PER_SEC << std::endl;

  return value;
}


void ElectrostaticInteraction_rec_FBSpline::calQ ()
{
  //   std::cerr << "K0  " << K[0] << std::endl;
  
  unsigned n = Mn->getN();

  for (unsigned i = 0; i < K[0] * K[1] * K[2]; i ++){
    Q[i] = 0;
  }
  double ii0 = 1./ value_type(K[0]);
  double ii1 = 1./ value_type(K[1]);
  double ii2 = 1./ value_type(K[2]);
  bool fast = ((n < K[0]) && (n < K[1]) && (n < K[2]));
  for (std::vector<StandardParticle * >::iterator ppart = partPool.begin();
       ppart != partPool.end(); ppart ++){
    std::vector<value_type > u(3);
    u[0] = K[0] * VectorOperation::dot (vecAStar[0], (*ppart)->r());
    u[1] = K[1] * VectorOperation::dot (vecAStar[1], (*ppart)->r());
    u[2] = K[2] * VectorOperation::dot (vecAStar[2], (*ppart)->r());
    value_type tmp0 = 0;
    value_type tmp1 = 0;
    value_type tmp2 = 0;

    int count = 0;
    if (!fast){
      for (unsigned k0 = 0; k0 < K[0]; k0 ++){
	for (unsigned k1 = 0; k1 < K[1]; k1 ++){
	  for (unsigned k2 = 0; k2 < K[2]; k2 ++, count ++){
	    value_type n0 = floor ((u[0] - k0) * ii0);
	    if (u[0] - k0 - n0 * K[0] < n){
	      Mn->value (u[0] - k0 - n0 * K[0], tmp0);
	    }
	    else{
	      continue;
	    }
	    value_type n1 = floor ((u[1] - k1) * ii1);
	    if (u[1] - k1 - n1 * K[1] < n){
	      Mn->value (u[1] - k1 - n1 * K[1], tmp1);
	    }
	    else{
	      continue;
	    }
	    value_type n2 = floor ((u[2] - k2) * ii2);
	    if (u[2] - k2 - n2 * K[2] < n){
	      Mn->value (u[2] - k2 - n2 * K[2], tmp2);
	    }
	    else{
	      continue;
	    }
	    Q[count] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
	  }
	}
      }
    }
    else {
      int A0 = -int(floor ((u[0]) * ii0)) ;
      int A1 = -int(floor ((u[1]) * ii1)) ;
      int A2 = -int(floor ((u[2]) * ii2)) ;
      value_type posi0 = u[0] + A0 * K[0];
      value_type posi1 = u[1] + A1 * K[1];
      value_type posi2 = u[2] + A2 * K[2];
      unsigned index0, index1;
      for (int k0 = int(ceil(posi0-n)); k0 < int(ceil(posi0)); ++ k0){
	Mn->value (posi0 - k0, tmp0);
	index0 = K[1] * (k0<0 ? k0+K[0] : k0);
	for (int k1 = int(ceil(posi1-n)); k1 < int(ceil(posi1)); ++ k1){
	  Mn->value (posi1 - k1, tmp1);
	  index1 = K[2] * ((k1<0 ? k1+K[1] : k1) + index0);
	  for (int k2 = int(ceil(posi2-n)); k2 < int(ceil(posi2)); ++ k2){
	    Mn->value (posi2 - k2, tmp2);
	    Q[(k2<0 ? k2+K[2] : k2) + index1] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
	  }
	}
      }
    }
  } 
}




//     if (posi0 < n){
//       for (unsigned k0 = 0; k0 < unsigned (ceil(posi0)); k0 ++){
// 	Mn->value (u[0] - k0 + A0 * K[0], tmp0);
// 	...;
//       }
//       for (unsigned k0 = unsigned(ceil(posi0+K[0]-n)); k0 < K[0]; k0 ++){
// 	Mn->value (u[0] - k0 + (A0+1) * K[0], tmp0);
// 	...;
//       }
//     }
//     else{
//       for (unsigned k0 = unsigned(ceil(posi0-n)); k0 < unsigned(ceil(posi0)); k0 ++){
// 	Mn->value (u[0] - k0 + A0 * K[0], tmp0);
// 	...;
//       }
//     }

//     if (posi1 < n){
//       for (unsigned k1 = 0; k1 < unsigned (ceil(posi1)); k1 ++){
// 	Mn->value (u[1] - k1 + A1 * K[1], tmp1);
// 	...;
//       }
//       for (unsigned k1 = unsigned(ceil(posi1+K[1]-n)); k1 < K[1]; k1 ++){
// 	Mn->value (u[1] - k1 + (A1+1) * K[1], tmp1);
// 	...;
//       }
//     }
//     else{
//       for (unsigned k1 = unsigned(ceil(posi1-n)); k1 < unsigned(ceil(posi1)); k1 ++){
// 	Mn->value (u[1] - k1 + A1 * K[1], tmp1);
// 	...;
//       }
//     }
		
//     if (posi2 < n){
//       for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 	Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 	Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
//       }
//       for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 	Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 	Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
//       }
//     }
//     else{
//       for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 	Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 	Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
//       }
//     }



void ElectrostaticInteraction_rec_FBSpline::init (const std::vector<std::vector<value_type > > &vecA_, 
						  const std::vector<unsigned > K_,
						  const value_type & beta_)
{
  Mn = new BSpline8 ();
  K = K_;
  beta = beta_;
  vecA = vecA_;
  calV();
  calAStar();
  calB ();

  int size = K[0] * K[1] * K[2];
  int sizeHalf = K[0] * K[1] * (K[2] / 2 + 1);
  Q	= (value_type *) fftw_malloc (sizeof(value_type) * size);
  psiF	= (fftw_complex *) fftw_malloc (sizeof(fftw_complex) * sizeHalf);
  QF	= (fftw_complex *) fftw_malloc (sizeof(fftw_complex) * sizeHalf);
  QFProdPsiF	= (fftw_complex *) fftw_malloc (sizeof(fftw_complex) * sizeHalf);
  QConvPsi	= (value_type *) fftw_malloc (sizeof(value_type) * size);

  forwardQ	= fftw_plan_dft_r2c_3d (K[0], K[1], K[2], Q  , QF  , FFTW_MEASURE);
  backwardQFProdPsiF = fftw_plan_dft_c2r_3d (K[0], K[1], K[2], QFProdPsiF, QConvPsi, FFTW_MEASURE);

  calPsiFPhiF();
}


void ElectrostaticInteraction_rec_FBSpline::clear()
{
  delete Mn;
  fftw_free (Q);
  fftw_free (QF);
  fftw_free (psiF);
  fftw_free (QFProdPsiF);
  fftw_free (QConvPsi);
  
  fftw_destroy_plan (forwardQ);
}


void ElectrostaticInteraction_rec_FBSpline::calB ()
{
  unsigned n = Mn->getN();
  b0.resize (K[0]);
  b1.resize (K[1]);
  b2.resize (K[2]);

  for (unsigned m = 0; m < K[0]; ++m){
    std::vector<value_type > fenzi (2);
    value_type tmp = 2 * M_PI * (n-1) * m / value_type (K[0]);
    fenzi[0] = cos(tmp);
    fenzi[1] = sin(tmp);
    std::vector<value_type > fenmu (2, 0);
    for (unsigned k = 0; k < n-1; k ++){
      value_type scale ;
      Mn->value (k+1, scale);
      tmp = 2 * M_PI * m * k / value_type (K[0]);
      fenmu[0] += scale * cos(tmp);
      fenmu[1] += scale * sin(tmp);
    }
    std::vector<value_type > btmp (2);
    value_type scale = 1./ (fenmu[0]*fenmu[0] + fenmu[1]*fenmu[1]);
    btmp[0] = scale * (fenzi[0] * fenmu[0] + fenzi[1] * fenmu[1]);
    btmp[1] = scale * (fenzi[1] * fenmu[0] - fenzi[0] * fenmu[1]);
    b0[m] = btmp[0]*btmp[0] + btmp[1]*btmp[1];
  }
  
  for (unsigned m = 0; m < K[1]; ++m){
    std::vector<value_type > fenzi (2);
    value_type tmp = 2 * M_PI * (n-1) * m / value_type (K[1]);
    fenzi[0] = cos(tmp);
    fenzi[1] = sin(tmp);
    std::vector<value_type > fenmu (2, 0);
    for (unsigned k = 0; k < n-1; k ++){
      value_type scale ;
      Mn->value (k+1, scale);
      tmp = 2 * M_PI * m * k / value_type (K[1]);
      fenmu[0] += scale * cos(tmp);
      fenmu[1] += scale * sin(tmp);
    }
    std::vector<value_type > btmp (2);
    value_type scale = 1./ (fenmu[0]*fenmu[0] + fenmu[1]*fenmu[1]);
    btmp[0] = scale * (fenzi[0] * fenmu[0] + fenzi[1] * fenmu[1]);
    btmp[1] = scale * (fenzi[1] * fenmu[0] - fenzi[0] * fenmu[1]);
    b1[m] = btmp[0]*btmp[0] + btmp[1]*btmp[1];
  }
  
  for (unsigned m = 0; m < K[2]; ++m){
    std::vector<value_type > fenzi (2);
    value_type tmp = 2 * M_PI * (n-1) * m / value_type (K[2]);
    fenzi[0] = cos(tmp);
    fenzi[1] = sin(tmp);
    std::vector<value_type > fenmu (2, 0);
    for (unsigned k = 0; k < n-1; k ++){
      value_type scale ;
      Mn->value (k+1, scale);
      tmp = 2 * M_PI * m * k / value_type (K[2]);
      fenmu[0] += scale * cos(tmp);
      fenmu[1] += scale * sin(tmp);
    }
    std::vector<value_type > btmp (2); 
    value_type scale = 1./ (fenmu[0]*fenmu[0] + fenmu[1]*fenmu[1]);
    btmp[0] = scale * (fenzi[0] * fenmu[0] + fenzi[1] * fenmu[1]);
    btmp[1] = scale * (fenzi[1] * fenmu[0] - fenzi[0] * fenmu[1]);
    b2[m] = btmp[0]*btmp[0] + btmp[1]*btmp[1];
  }
  
}




void ElectrostaticInteraction_rec_FBSpline::calPsiFPhiF ()
{
  fftw_complex * psiFtmp;
  
  psiFtmp= (fftw_complex *) fftw_malloc (sizeof(fftw_complex) * K[0]*K[1]*K[2]);

  value_type oneOver2PiV = 1. / (2 * M_PI * V);
  value_type scale = M_PI * M_PI / beta / beta;
  unsigned size = K[0]*K[1]*K[2];
  
  psiFtmp[0][0] = 0;
  psiFtmp[0][1] = 0;
  std::vector<value_type > m (3);
  for (unsigned i = 0; i < K[0]; i ++){
    int ip ;    
    if (i <= K[0] / 2) ip = i;
    else ip = i - K[0];
    for (unsigned j = 0; j < K[1]; j ++){
      int jp;      
      if (j <= K[1] / 2) jp = j;
      else jp = j - K[1];
      for (unsigned k = 0; k < K[2]; k ++){
	int kp ;        
	if (k <= K[2] / 2) kp = k;
	else kp = k - K[2];

	if (kp == 0 && jp == 0 && ip == 0) continue;
	m[0] = ip * vecAStar[0][0] + jp * vecAStar[1][0] + kp * vecAStar[2][0];
	m[1] = ip * vecAStar[0][1] + jp * vecAStar[1][1] + kp * vecAStar[2][1];
	m[2] = ip * vecAStar[0][2] + jp * vecAStar[1][2] + kp * vecAStar[2][2];
	value_type mm = VectorOperation::dot (m, m);
	value_type expm = exp (-scale * mm) / mm * b0[i] * b1[j] * b2[k];
	psiFtmp[k + K[2] * (j + K[1] * i)][0] = oneOver2PiV * expm * size;
	psiFtmp[k + K[2] * (j + K[1] * i)][1] = 0;
      }
    }
  }
  

  for (unsigned i = 0; i < K[0]; ++ i){
    for (unsigned j = 0; j < K[1]; ++ j){
      for (unsigned k = 0; k < K[2]/2+1; ++ k){
	psiF[k+(K[2]/2+1)*(j+K[1]*i)][0] = psiFtmp[k+K[2]*(j+K[1]*i)][0];
	psiF[k+(K[2]/2+1)*(j+K[1]*i)][1] = psiFtmp[k+K[2]*(j+K[1]*i)][1];
      }
    }
  }

  fftw_free (psiFtmp);
}




void ElectrostaticInteraction_rec_FBSpline::calV()
{
  V = vecA[0][0] * (vecA[1][1]*vecA[2][2] - vecA[2][1]*vecA[1][2]) - 
    vecA[0][1] * (vecA[1][0]*vecA[2][2] - vecA[2][0]*vecA[1][2]) +
    vecA[0][2] * (vecA[1][0]*vecA[2][1] - vecA[2][0]*vecA[1][1]);
}
  
void ElectrostaticInteraction_rec_FBSpline::calAStar ()
{
  vecAStar.resize (3);
  vecAStar[0].resize (3);
  vecAStar[1].resize (3);
  vecAStar[2].resize (3);
  vecAStar[0][0] =( vecA[1][1]*vecA[2][2] - vecA[2][1]*vecA[1][2]) / V;
  vecAStar[1][1] =( vecA[0][0]*vecA[2][2] - vecA[2][0]*vecA[0][2]) / V;
  vecAStar[2][2] =( vecA[0][0]*vecA[1][1] - vecA[1][0]*vecA[0][1]) / V;
  vecAStar[1][0] =(-vecA[1][0]*vecA[2][2] + vecA[2][0]*vecA[1][2]) / V;
  vecAStar[2][0] =( vecA[1][0]*vecA[2][1] - vecA[2][0]*vecA[1][1]) / V;
  vecAStar[0][1] =(-vecA[0][1]*vecA[2][2] + vecA[2][1]*vecA[0][2]) / V;
  vecAStar[2][1] =(-vecA[0][0]*vecA[2][1] + vecA[2][0]*vecA[0][1]) / V;
  vecAStar[0][2] =( vecA[0][1]*vecA[1][2] - vecA[1][1]*vecA[0][2]) / V;
  vecAStar[1][2] =(-vecA[0][0]*vecA[1][2] + vecA[1][0]*vecA[0][2]) / V;
}




//       if (posi0 < n){
// 	for (unsigned k0 = 0; k0 < unsigned (ceil(posi0)); k0 ++){
// 	  Mn->value (u[0] - k0 + A0 * K[0], tmp0);
// 	  Mn->derivative (u[0] - k0 + A0 * K[0], dtmp0);
// 	  if (posi1 < n){
// 	    for (unsigned k1 = 0; k1 < unsigned (ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);
// 	      Mn->derivative (u[1] - k1 + A1 * K[1], dtmp1);
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + (A2+1) * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	    }
// 	    for (unsigned k1 = unsigned(ceil(posi1+K[1]-n)); k1 < K[1]; k1 ++){
// 	      Mn->value (u[1] - k1 + (A1+1) * K[1], tmp1);
// 	      Mn->derivative (u[1] - k1 + (A1+1) * K[1], dtmp1);
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + (A2+1) * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	    }
// 	  }
// 	  else{
// 	    for (unsigned k1 = unsigned(ceil(posi1-n)); k1 < unsigned(ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);
// 	      Mn->derivative (u[1] - k1 + A1 * K[1], dtmp1);
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + (A2+1) * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	    }
// 	  }
// 	}
// 	for (unsigned k0 = unsigned(ceil(posi0+K[0]-n)); k0 < K[0]; k0 ++){
// 	  Mn->value (u[0] - k0 + (A0+1) * K[0], tmp0);
// 	  Mn->derivative (u[0] - k0 + (A0+1) * K[0], dtmp0);
// 	  if (posi1 < n){
// 	    for (unsigned k1 = 0; k1 < unsigned (ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);
// 	      Mn->derivative (u[1] - k1 + A1 * K[1], dtmp1);
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + (A2+1) * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	    }
// 	    for (unsigned k1 = unsigned(ceil(posi1+K[1]-n)); k1 < K[1]; k1 ++){
// 	      Mn->value (u[1] - k1 + (A1+1) * K[1], tmp1);
// 	      Mn->derivative (u[1] - k1 + (A1+1) * K[1], dtmp1);
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + (A2+1) * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	    }
// 	  }
// 	  else{
// 	    for (unsigned k1 = unsigned(ceil(posi1-n)); k1 < unsigned(ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);
// 	      Mn->derivative (u[1] - k1 + A1 * K[1], dtmp1);
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + (A2+1) * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	    }
// 	  }
// 	}
//       }
//       else{
// 	for (unsigned k0 = unsigned(ceil(posi0-n)); k0 < unsigned(ceil(posi0)); k0 ++){
// 	  Mn->value (u[0] - k0 + A0 * K[0], tmp0);
// 	  Mn->derivative (u[0] - k0 + A0 * K[0], dtmp0);
// 	  if (posi1 < n){
// 	    for (unsigned k1 = 0; k1 < unsigned (ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);
// 	      Mn->derivative (u[1] - k1 + A1 * K[1], dtmp1);
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + (A2+1) * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	    }
// 	    for (unsigned k1 = unsigned(ceil(posi1+K[1]-n)); k1 < K[1]; k1 ++){
// 	      Mn->value (u[1] - k1 + (A1+1) * K[1], tmp1);
// 	      Mn->derivative (u[1] - k1 + (A1+1) * K[1], dtmp1);
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + (A2+1) * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	    }
// 	  }
// 	  else{
// 	    for (unsigned k1 = unsigned(ceil(posi1-n)); k1 < unsigned(ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);
// 	      Mn->derivative (u[1] - k1 + A1 * K[1], dtmp1);
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + (A2+1) * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Mn->derivative (u[2] - k2 + A2 * K[2], dtmp2);
// 		  unsigned index = k2+K[2]*(k1+K[1]*k0);
// 		  VectorOperation::add (force, -QConvPsi[index] * dtmp0 * tmp1 * tmp2 * K[0], vecAStar[0]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * dtmp1 * tmp2 * K[1], vecAStar[1]);
// 		  VectorOperation::add (force, -QConvPsi[index] * tmp0 * tmp1 * dtmp2 * K[2], vecAStar[2]);
// 		}
// 	      }
// 	    }
// 	  }
// 	}
//       }






//       if (posi0 < n){
// 	for (unsigned k0 = 0; k0 < unsigned (ceil(posi0)); k0 ++){
// 	  Mn->value (u[0] - k0 + A0 * K[0], tmp0);
// 	  if (posi1 < n){
// 	    for (unsigned k1 = 0; k1 < unsigned (ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);	      
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	    }
// 	    for (unsigned k1 = unsigned(ceil(posi1+K[1]-n)); k1 < K[1]; k1 ++){
// 	      Mn->value (u[1] - k1 + (A1+1) * K[1], tmp1);	      
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	    }
// 	  }
// 	  else{
// 	    for (unsigned k1 = unsigned(ceil(posi1-n)); k1 < unsigned(ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);	      
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	    }
// 	  }
// 	}
// 	for (unsigned k0 = unsigned(ceil(posi0+K[0]-n)); k0 < K[0]; k0 ++){
// 	  Mn->value (u[0] - k0 + (A0+1) * K[0], tmp0);
// 	  if (posi1 < n){
// 	    for (unsigned k1 = 0; k1 < unsigned (ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);	      
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	    }
// 	    for (unsigned k1 = unsigned(ceil(posi1+K[1]-n)); k1 < K[1]; k1 ++){
// 	      Mn->value (u[1] - k1 + (A1+1) * K[1], tmp1);	      
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	    }
// 	  }
// 	  else{
// 	    for (unsigned k1 = unsigned(ceil(posi1-n)); k1 < unsigned(ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);	      
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	    }
// 	  }
// 	}
//       }
//       else{
// 	for (unsigned k0 = unsigned(ceil(posi0-n)); k0 < unsigned(ceil(posi0)); k0 ++){
// 	  Mn->value (u[0] - k0 + A0 * K[0], tmp0);
// 	  if (posi1 < n){
// 	    for (unsigned k1 = 0; k1 < unsigned (ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);	      
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	    }
// 	    for (unsigned k1 = unsigned(ceil(posi1+K[1]-n)); k1 < K[1]; k1 ++){
// 	      Mn->value (u[1] - k1 + (A1+1) * K[1], tmp1);	      
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	    }
// 	  }
// 	  else{
// 	    for (unsigned k1 = unsigned(ceil(posi1-n)); k1 < unsigned(ceil(posi1)); k1 ++){
// 	      Mn->value (u[1] - k1 + A1 * K[1], tmp1);	      
// 	      if (posi2 < n){
// 		for (unsigned k2 = 0; k2 < unsigned (ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 		for (unsigned k2 = unsigned(ceil(posi2+K[2]-n)); k2 < K[2]; k2 ++){
// 		  Mn->value (u[2] - k2 + (A2+1) * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	      else{
// 		for (unsigned k2 = unsigned(ceil(posi2-n)); k2 < unsigned(ceil(posi2)); k2 ++){
// 		  Mn->value (u[2] - k2 + A2 * K[2], tmp2);
// 		  Q[k2+K[2]*(k1+K[1]*k0)] += (*ppart)->charge() * tmp0 * tmp1 * tmp2;
// 		}
// 	      }
// 	    }
// 	  }
// 	}
//       }


